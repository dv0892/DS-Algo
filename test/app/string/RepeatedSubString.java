package test.app.string;

public class RepeatedSubString {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println( new RepeatedSubString().repeatedSubstringPattern("abcabcabc"));
	}
	
	public boolean repeatedSubstringPattern(String s) {
		
		/* 
		 * Brute force approach will work :
		 * The idea is to start picking substring and check if they form a pattern 
		 * in remaining string. We will do this substring picking only till half of
		 * actual string because that will be biggest substring that can repeat.
		 * 
		 * Here one optimization that we can use is avoid usage of
		 * substring that is quite memory intensive.
		 * 
		 * Excellent example of Excessive Garbage generated by sub string.
		 */
        
		int n = s.length();
		char[] arr = s.toCharArray();
		
		/*for(int i = 0; i<n/2; i++) {
			String sub = s.substring(0,i+1);
			int    len = i+1;
			
			int j = i + 1;
			for( ; j<n; j+=(i+1) ) {
				
				if( (j+len) > n) {
					break;
				}
				
				String t = s.substring(j, j + len);
				if(!t.equals(sub))
					break;
			}
			
			if( j == (n))
				return true;
		}*/
		
		for(int i = 0; i<n/2; i++) {
			int len = i+1;
			int j = i + 1;
			
			for( ; j<n; j+=(i+1) ) {
				if(!equals(arr,j,len))
					break;
			}
			
			if( j == (n))
				return true;
		}
		
		return false;
    }

	private boolean equals(char[] arr, int j, int len) {
		
		if( (j+len) > arr.length) {
			return false;
		}
		
		int i = 0 ;
		while ( i < len )
			if(arr[i++] != arr[j++])
				return false;

		return true;
	}

}
